section.center data-background="#000"
  h1.white Implementing Web Console
  p.red <span class="white">by</span> Genadi Samokovarov

section.center
  h2 üëã

section.center
  img.inline src=image_path("me.png")
  h2.fragment Genadi Samokovarov

section.center
  h2 „Ç≤„Éä„Éá„Ç£„Éª„Çµ„É¢„Ç≥„É¥„Ç°„É≠„Éï

section.center data-background="#000"
  h2.white „Ç≤„Éä„Éá„Ç£„Éª„Çµ„É¢„Ç≥„É¥„Ç°„É≠„Éï

section.center data-background="#000"
  h2.white „Ç≤„Éä„Éá„Ç£
  p.white &nbsp;

section.center data-background="#000"
  h2.white <span class="red">„Ç≤</span>„Éä„Éá„Ç£
  span.fragment
    p.white „Ç≤„ÉÉ„Éà (get)

section.center data-background="#000"
  h2.white „Ç≤<span class="red">„Éä</span>„Éá„Ç£
  span.fragment
    p.white „Éä„Ç§„Çπ (nice)

section.center data-background="#000"
  h2.white „Ç≤„Éä<span class="red">„Éá„Ç£</span>
  span.fragment
    p.white „Éá„Ç£„Éº„Ç∏„Çß„Ç§ (DJ)

section.center data-background=image_path("dj.jpg")
  p.white.shadow.fragment I do events!

section.center
  a(href="https://twitter.com/gsamokovarov") twitter.com/gsamokovarov

section.center
  a(href="https://github.com/gsamokovarov") github.com/gsamokovarov

section.center
  a href="https://rhyme.com"
    img.inline src=image_path("rhyme.svg")

section.center data-background="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Flag_of_Bulgaria.svg/2000px-Flag_of_Bulgaria.svg.png"
  h2.white.shadow Bulgaria
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Bulgaria"

section.center data-background="https://www.mapsland.com/maps/europe/bulgaria/large-location-map-of-bulgaria.jpg"
  h2.shadow Bulgaria
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Bulgaria"

section data-background="https://cdn2.wanderlust.co.uk/media/2637/articles-public-mineral-baths-sofia-bulgaria-dreamstime.jpg"
  h2.white.shadow Sofia
  = copyright "Wanderlust", "https://www.wanderlust.co.uk/content/short-break-guide-to-sofia-bulgaria/"

section data-background="https://cdn2.wanderlust.co.uk/media/2632/magazine-1335.jpg"
  h2.white.shadow Sofia
  = copyright "Wanderlust", "https://www.wanderlust.co.uk/content/short-break-guide-to-sofia-bulgaria/"

section data-background="https://cdn2.wanderlust.co.uk/media/2633/magazine-2328.jpg"
  h2.white.shadow Sofia
  = copyright "Wanderlust", "https://www.wanderlust.co.uk/content/short-break-guide-to-sofia-bulgaria/"

section.center
  p –ê –ë –í –ì –î –ï –ñ –ó –ò –ô –ö –õ –ú –ù –û –ü –† –° –¢ –£ –§ –• –¶ –ß –® –© –™ –¨ –Æ –Ø
  hr
  p –∞ –± –≤ –≥ –¥ –µ –∂ –∑ –∏ –π –∫ –ª –º –Ω –æ –ø —Ä —Å —Ç —É —Ñ —Ö —Ü —á —à —â —ä —å —é —è
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Cyrillic_script"

section.center data-background="https://upload.wikimedia.org/wikipedia/commons/9/96/20101210_014809_LactobacillusBulgaricus.jpg"
  p.white.shadow Lactobacillus delbrueckii subsp. bulgaricus
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Lactobacillus_delbrueckii_subsp._bulgaricus"

section.center data-background="https://upload.wikimedia.org/wikipedia/commons/9/90/Atanasoff-Berry_Computer.jpg"
  h2.white.shadow John Atanasoff
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/John_Vincent_Atanasoff#/media/File:Atanasoff-Berry_Computer.jpg"

section.center data-background=image_path("dj.jpg")
  p.white.shadow I do events!

section.center data-background=image_path("dj.jpg")
  p.white.shadow() (literally)

section.center data-background=image_path("dj.jpg")
  p.white.shadow üòÖ

section.center data-background="#FCD846"
  a href="https://balkanruby.com"
    img.inline src=image_path("balkan.svg")

section.center data-background="#2196F3"
  a href="http://partialconf.com"
    img.inline src=image_path("partial.svg")

section.center data-background="#000"
  h2.white.fragment What is Web Console<span class="red">?</span>

section.center data-background="#000"
  p.white A debugger that doesn't stop the world üåç

section.center data-background="#000"
  p.white Included by default in <span class="red">Rails 4.2</span>.

section.center
  pre(contenteditable=true): code.ruby
    '
      group :development do
        gem 'listen', '>= 3.0.5', '< 3.2'
        gem 'web-console'
        gem 'spring'
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      group :development do
        gem 'listen', '>= 3.0.5', '< 3.2'
        gem 'web-console' üëà
        gem 'spring'
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      group :development do
        gem 'listen', '>= 3.0.5', '< 3.2'
        gem 'web-console' üëå
        gem 'spring'
      end

section.center data-background="#F0F"
  p.white An interactive puts üòé

section.center data-background="#F0F"
  = copyright "Demo", "http://localhost:3000"

section.center data-background="http://i.imgur.com/FoSU23L.gif"
  = copyright "Demo", "http://localhost:3000"

section.center
  .fragment
    p Á¥†Êô¥„Çâ„Åó„ÅÑ„Åß„Åô ü§ó
    p <em>(Subarashƒ´desu)</em>

section.center data-background="#000"
  h2.white How does Web Console work<span class="red">?</span>
  = copyright "rails/web-console", "https://github.com/rails/web-console"

section.center
  a(href="https://github.com/rails/web-console") rails/web-console

section.center data-background="#F00"
  h2.white Rack<span class="black">!</span>

section.center
  img.inline src=image_path("browser_to_rails.svg")

section.center
  img.inline src=image_path("browser_to_rails_with_web_console.svg")

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.from_whitelisted_ip?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.from_whitelisted_ip? üëà

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.from_whitelisted_ip?

          if id = id_for_repl_session_update(request) üëà
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center data-background-iframe="/console"
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.from_whitelisted_ip?

          if id = id_for_repl_session_update(request) üëà
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.from_whitelisted_ip?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request) üëà
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center data-background-iframe="/console"
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.from_whitelisted_ip?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request) üëà
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.from_whitelisted_ip?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env) üëà

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  img.inline src=image_path("browser_to_rails_with_web_console.svg")

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.from_whitelisted_ip?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.from_whitelisted_ip?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers) üëà
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.from_whitelisted_ip?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ] üëà
        end
      end

section.center
  pre.fragment(contenteditable=true): code.ruby
    '
      module Kernel
        module_function

        def console(binding = Bindex.current_bindings.second)
          Thread.current[:__web_console_binding] = binding

          nil
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      module Kernel
        module_function üëà

        def console(binding = Bindex.current_bindings.second)
          Thread.current[:__web_console_binding] = binding

          nil
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      module Kernel
        module_function

        def console(binding = Bindex.current_bindings.second)
          Thread.current[:__web_console_binding] = binding

          nil üëà
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Session
        cattr_reader :inmemory_storage, default: {}

        attr_reader :id

        def initialize(bindings)
          @id = SecureRandom.hex(16)
          @bindings = bindings
          @evaluator = Evaluator.new(@current_binding = bindings.first)

          store_into_memory
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Session
        cattr_reader :inmemory_storage, default: {} üëà

        attr_reader :id

        def initialize(bindings)
          @id = SecureRandom.hex(16)
          @bindings = bindings
          @evaluator = Evaluator.new(@current_binding = bindings.first)

          store_into_memory
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Session
        cattr_reader :inmemory_storage, default: {}

        attr_reader :id

        def initialize(bindings)
          @id = SecureRandom.hex(16) üëà
          @bindings = bindings
          @evaluator = Evaluator.new(@current_binding = bindings.first)

          store_into_memory
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Session
        cattr_reader :inmemory_storage, default: {}

        attr_reader :id

        def initialize(bindings)
          @id = SecureRandom.hex(16)
          @bindings = bindings
          @evaluator = Evaluator.new(@current_binding = bindings.first) üòÖ

          store_into_memory
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Session
        cattr_reader :inmemory_storage, default: {}

        attr_reader :id

        def initialize(bindings)
          @id = SecureRandom.hex(16)
          @bindings = bindings
          @evaluator = Evaluator.new(@current_binding = bindings.first)

          store_into_memory üëà
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Session
        def eval(input)
          @evaluator.eval(input)
        end
      end

section.center data-background="#F0F"
  h2.white Limitations<span class="black">!</span>

section.center
  p Sessions can be stored <span class="shadow">only</span> in memory<span class="red">!</span>

section.center
  p A problem for <span class="red">multi-process</span> servers in development.

section.center
  p The sessions are <span class="shadow">never</span> cleaned up!

section.center
  h3 üóë

section.center
  p Remote Code Execution (<span class="red">RCE</span>)

section.center data-background="#000"
  h2.white üòÖ

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Evaluator
        def initialize(binding = TOPLEVEL_BINDING)
          @binding = binding
        end

        def eval(input)
          &quot;=&gt; \#{@binding.eval(input).inspect}\n&quot;
        rescue Exception => exc
          format_exception(exc)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Evaluator
        def initialize(binding = TOPLEVEL_BINDING)
          @binding = binding
        end

        def eval(input)
          &quot;=&gt; \#{@binding.eval(input).inspect}\n&quot; üëà
        rescue Exception => exc
          format_exception(exc)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Evaluator
        def initialize(binding = TOPLEVEL_BINDING)
          @binding = binding
        end

        def eval(input)
          &quot;=&gt; \#{@binding.eval(input).inspect}\n&quot;
        rescue Exception => exc üëà
          format_exception(exc)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Evaluator
        def initialize(binding = TOPLEVEL_BINDING)
          @binding = binding
        end

        def eval(input)
          &quot;=&gt; \#{@binding.eval(input).inspect}\n&quot;
        rescue => exc üëà
          format_exception(exc)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Evaluator
        def initialize(binding = TOPLEVEL_BINDING)
          @binding = binding
        end

        def eval(input)
          &quot;=&gt; \#{@binding.eval(input).inspect}\n&quot;
        rescue StandardError => exc üëà
          format_exception(exc)
        end
      end

section.center data-background="#000"
  h2.white Exceptions

section.center data-background="#000"
  pre.white(contenteditable=true)
    '
      Exception
        NoMemoryError
        ScriptError
          LoadError
          NotImplementedError
          SyntaxError
        SecurityError
        SignalException
          Interrupt
        StandardError -- default for rescue
        SystemExit
        SystemStackError
        fatal ‚Äì- impossible to rescue

section.center data-background="#000"
  pre.white(contenteditable=true)
    '
      StandardError -- default for rescue
        ArgumentError
        EncodingError
        FiberError
        IOError
          EOFError
        IndexError
          KeyError
          StopIteration
        LocalJumpError
        NameError
          NoMethodError
        RangeError
          FloatDomainError
        RegexpError
        RuntimeError -- default for raise
        SystemCallError
          Errno::*
        ThreadError
        TypeError
        ZeroDivisionError

section.center data-background="#000"
  h2.white Kernel#raise

section.center
  pre(contenteditable=true): code.ruby
    '
      raise
      raise "Too lazy to define own error class..."
      raise Error, "Oops", caller

section.center
  p The backtrace is normally produced using the <span class="red">Kernel#caller</span> method.

section.center data-background="#000"
  h2.white Kernel#caller

section.center
  pre(contenteditable=true): code.shell
    '
      &gt;&gt; puts caller
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/workspace.rb:85:in `eval'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/workspace.rb:85:in `evaluate'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/context.rb:380:in `evaluate'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:491:in `block (2 levels) in eval_input'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:621:in `signal_status'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:488:in `block in eval_input'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/ruby-lex.rb:246:in `block (2 levels) in each_top_level_statement'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/ruby-lex.rb:232:in `loop'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/ruby-lex.rb:232:in `block in each_top_level_statement'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/ruby-lex.rb:231:in `catch'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/ruby-lex.rb:231:in `each_top_level_statement'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:487:in `eval_input'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:428:in `block in run'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:427:in `catch'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:427:in `run'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:383:in `start'
      /Users/genadi/.rbenv/versions/2.5.0/bin/irb:11:in `&lt;main&gt;'
      =&gt; nil

section.center
  p Reflection of the current thread stack frames as readable text.

section.center
  p Represented as an Array of String objects.

section.center data-background="#000"
  h2.white Kernel#caller_locations

section.center
  p The same as Kernel#caller, but returns an Array of Thread::Backtrace::Location objects.

section.center
  pre(contenteditable=true): code.shell
    '
      &gt;&gt; puts caller_locations
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/workspace.rb:85:in `eval'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/workspace.rb:85:in `evaluate'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/context.rb:380:in `evaluate'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:491:in `block (2 levels) in eval_input'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:621:in `signal_status'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:488:in `block in eval_input'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/ruby-lex.rb:246:in `block (2 levels) in each_top_level_statement'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/ruby-lex.rb:232:in `loop'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/ruby-lex.rb:232:in `block in each_top_level_statement'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/ruby-lex.rb:231:in `catch'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/ruby-lex.rb:231:in `each_top_level_statement'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:487:in `eval_input'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:428:in `block in run'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:427:in `catch'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:427:in `run'
      /Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb.rb:383:in `start'
      /Users/genadi/.rbenv/versions/2.5.0/bin/irb:11:in `&lt;main&gt;'
      =&gt; nil

section.center
  pre(contenteditable=true): code.shell
    '
      &gt;&gt; caller_locations.first.path
      =&gt; &quot;/Users/genadi/.rbenv/versions/2.5.0/lib/ruby/2.5.0/irb/workspace.rb&quot;
      &gt;&gt; caller_locations.first.label
      =&gt; &quot;eval&quot;
      &gt;&gt; caller_locations.first.lineno
      =&gt; 85

section.center data-background="#000"
  h2.white Binding

section.center data-background=image_path("aaron_binding.png")
  .shadow.fragment
    blockquote "Basically, an implementor's nightmare!"
    p Aaron Patterson

section.center data-background="#000"
  p.white Encapsulate the execution context at a particular place in the code.

section.center data-background="#000"
  p.white Retain this context for future use.

section.center
  p Local variables

section.center
  p Instance variables

section.center
  p Methods

section.center
  p self

section.center
  p The current class

section.center
  p __FILE__

section.center
  p __LINE__

section.center data-background="#000"
  p.white Binding#<span class="red">eval</span> <span class="fragment">üëà</span>

section.center data-background="#000"
  p.white Usually created by <span class="red">Kernel#binding</span>.

section.center data-background="#000"
  p.white Created <strong>only</strong> for the current thread stack frame!

section.center data-background="#000"
  p.white Keeps a reference to <span class="red">everything</span> the current context can touch.

section.center
  h2 ü§î

section.center
  h2 Binding#pry
  p binding.pry

section.center
  h2 Binding#irb
  p binding.irb

section.center
  h2 Kernel#console
  p console

section.center
  pre(contenteditable=true): code.ruby
    '
      module Kernel
        module_function

        def console(binding = Bindex.current_bindings.second)
          Thread.current[:__web_console_binding] = binding

          nil
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      module Kernel
        module_function

        def console(binding = Bindex.current_bindings.second) üëà
          Thread.current[:__web_console_binding] = binding

          nil
        end
      end

section.center data-background="#F00"
  h2.white Binding#console
  p.white binding.console

section.center data-background="#F00"
  h2 üòÖ

section.center data-background="#F00"
  h2.white Bindex

section.center data-background="#000"
  h2.white Bindex

section.center data-background="#00F"
  h2.white Bindex

section.center
  p Cross-platform utilities for building <span class="red">Binding</span> objects.

section.center
  p CRuby

section.center
  p JRuby

section.center
  p Rubinius

section.center data-background="#000"
  h2.white ‚úåÔ∏è

section.center data-background="#F00"
  h2.white ‚òùÔ∏è

section.center data-background="#F00"
  h2.white Bindex.current_bindings

section.center
  pre(contenteditable=true): code.c
    '
      static VALUE
      current_bindings(void)
      {
        return rb_debug_inspector_open(current_bindings_callback, NULL);
      }

section.center
  pre(contenteditable=true): code.c
    '
      static VALUE
      current_bindings_callback(const rb_debug_inspector_t *context, void *data)
      {
        VALUE locations = rb_debug_inspector_backtrace_locations(context);
        VALUE binding, bindings = rb_ary_new();
        long i, length = RARRAY_LEN(locations);

        for (i = 0; i < length; i++) {
          binding = rb_debug_inspector_frame_binding_get(context, i);

          if (!NIL_P(binding)) {
            rb_ary_push(bindings, binding);
          }
        }

        return bindings;
      }

section.center
  pre(contenteditable=true): code.c
    '
      static VALUE
      bx_current_bindings(VALUE self)
      {
        return current_bindings();
      }

section.center
  pre(contenteditable=true): code.c
    '
      void
      Init_cruby(void)
      {
        bx_mBindex = rb_define_module("Bindex");

        rb_define_singleton_method(bx_mBindex, "current_bindings", bx_current_bindings, 0);
      }

section.center data-background="#000"
  h2.white Debug Inspector API <span class="red fragment">(CRuby)</span>

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  p Straight outta ruby/ruby.h üòÖ

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data); üëà
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *); üëà

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc); üëà

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index); üëà
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index); üëà
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index); üëà
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center
  pre(contenteditable=true): code.c
    '
      /* debug inspector APIs */
      typedef struct rb_debug_inspector_struct rb_debug_inspector_t;
      typedef VALUE (*rb_debug_inspector_func_t)(const rb_debug_inspector_t *, void *);

      VALUE rb_debug_inspector_open(rb_debug_inspector_func_t func, void *data);
      VALUE rb_debug_inspector_frame_self_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_class_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_binding_get(const rb_debug_inspector_t *dc, long index);
      VALUE rb_debug_inspector_frame_iseq_get(const rb_debug_inspector_t *dc, long index); üëà
      VALUE rb_debug_inspector_backtrace_locations(const rb_debug_inspector_t *dc);

section.center data-background="#00F"
  h2.white ‚úåÔ∏è

section.center data-background="#00F"
  h2.white Exception#bindings

section.center
  pre(contenteditable=true): code.c
    '
      static void
      set_exception_bindings_on_raise(void)
      {
        VALUE tpval = rb_tracepoint_new(0, RUBY_EVENT_RAISE, set_exception_bindings_callback, 0);
        rb_tracepoint_enable(tpval);
      }


section.center
  pre(contenteditable=true): code.c
    '
      static void
      set_exception_bindings_callback(VALUE tpval, void *data)
      {
        rb_trace_arg_t *trace_arg = rb_tracearg_from_tracepoint(tpval);
        VALUE exception = rb_tracearg_raised_exception(trace_arg);
        VALUE bindings = rb_attr_get(exception, id_bindings);

        /* Set the bindings, only if they haven't been set already. This may reset
         * the binding during reraise. */
        if (NIL_P(bindings)) {
          rb_ivar_set(exception, id_bindings, current_bindings());
        }
      }

section.center
  pre(contenteditable=true): code.c
    '
      static VALUE
      bx_exc_bindings(VALUE self)
      {
        VALUE bindings = rb_attr_get(self, id_bindings);

        if (NIL_P(bindings)) {
          bindings = rb_ary_new();
        }

        return bindings;
      }

section.center
  pre(contenteditable=true): code.c
    '
      void
      Init_cruby(void)
      {
        bx_mBindex = rb_define_module("Bindex");
        id_bindings = rb_intern("bindings");

        rb_define_method(rb_eException, "bindings", bx_exc_bindings, 0);

        set_exception_bindings_on_raise();
      }

section.center data-background="#000"
  h2.white TracePoint

section.center
  p Provides Object-Oriented API for the functionality of <span class="red">Kernel#set_trace_func</span>.

section.center
  pre(contenteditable=true): code.ruby
    '
      trace = TracePoint.new(:raise) do |tp|
        p [tp.lineno, tp.event, tp.raised_exception]
      end
      #=&gt; #&lt;TracePoint:disabled&gt;

      trace.enable
      #=&gt; false

      0 / 0
      #=&gt; [5, :raise, #&lt;ZeroDivisionError: divided by 0&gt;]

section.center
  h3 line
  p execute code on a new line

section.center
  h3 class
  p start a class or module definition

section.center
  h3 end
  p finish a class or module definition

section.center
  h3 call
  p call a Ruby method

section.center
  h3 return
  p return from a Ruby method

section.center
  h3 c_call
  p call a C-language routine

section.center
  h3 c_return
  p return from a C-language routine

section.center
  h3 raise
  p raise an exception

section.center data-background="#000"
  h3.white raise
  p.white raise an exception

section.center
  h3 b_call
  p event hook at block entry

section.center
  h3 b_return
  p event hook at block ending

section.center
  h3 thread_begin
  p event hook at thread beginning

section.center
  h3 thread_end
  p event hook at thread ending

section.center
  h3 fiber_switch
  p event hook at fiber switch

section.center data-background="#000"
  h2.white Error Handling in <span class="red">Rails</span>

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      use Rack::Sendfile
      use ActionDispatch::Static
      use ActionDispatch::Executor
      use ActiveSupport::Cache::Strategy::LocalCache::Middleware
      use Rack::Runtime
      use Rack::MethodOverride
      use ActionDispatch::RequestId
      use ActionDispatch::RemoteIp
      use Sprockets::Rails::QuietAssets
      use Rails::Rack::Logger
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::Reloader
      use ActionDispatch::Callbacks
      use ActiveRecord::Migration::CheckPending
      use ActionDispatch::Cookies
      use ActionDispatch::Session::CookieStore
      use ActionDispatch::Flash
      use ActionDispatch::ContentSecurityPolicy::Middleware
      use Rack::Head
      use Rack::ConditionalGet
      use Rack::ETag
      use Rack::TempfileReaper
      run Banitsa::Application.routes

section.center
  img.inline src=image_path("browser_to_rails_with_web_console.svg")

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      use Rack::Sendfile
      use ActionDispatch::Static
      use ActionDispatch::Executor
      use ActiveSupport::Cache::Strategy::LocalCache::Middleware
      use Rack::Runtime
      use Rack::MethodOverride
      use ActionDispatch::RequestId
      use ActionDispatch::RemoteIp
      use Sprockets::Rails::QuietAssets
      use Rails::Rack::Logger
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::Reloader
      use ActionDispatch::Callbacks
      use ActiveRecord::Migration::CheckPending
      use ActionDispatch::Cookies
      use ActionDispatch::Session::CookieStore
      use ActionDispatch::Flash
      use ActionDispatch::ContentSecurityPolicy::Middleware
      use Rack::Head
      use Rack::ConditionalGet
      use Rack::ETag
      use Rack::TempfileReaper
      run Banitsa::Application.routes

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions üëà
      # ...

section.center data-background="#F00"
  h2.white ActionDispatch::DebugExceptions

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env) üëà

          response
        rescue Exception => exception
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception)
        end
      end

section.center
  img.inline src=image_path("browser_to_rails.svg")

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception üëà
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception) üëà
        end
      end

section.center data-background-iframe="/error"
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions üëà
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      # ...

section.center data-background="#F00"
  h2.white ActionDispatch::ShowExceptions

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ShowExceptions
        FAILSAFE_RESPONSE = [500, { "Content-Type" => "text/plain" },
          ["500 Internal Server Error\n" ...]

        def initialize(app, exceptions_app)
          @app = app
          @exceptions_app = exceptions_app
        end

        def call(env)
          request = ActionDispatch::Request.new env
          @app.call(env)
        rescue Exception => exception
          if request.show_exceptions?
            render_exception(request, exception)
          else
            raise exception
          end
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ShowExceptions
        FAILSAFE_RESPONSE = [500, { "Content-Type" => "text/plain" },
          ["500 Internal Server Error\n"]]

        def initialize(app, exceptions_app)
          @app = app
          @exceptions_app = exceptions_app
        end

        def call(env)
          request = ActionDispatch::Request.new env
          @app.call(env)
        rescue Exception => exception
          if request.show_exceptions?
            render_exception(request, exception) üëà
          else
            raise exception
          end
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ShowExceptions
        FAILSAFE_RESPONSE = [500, { "Content-Type" => "text/plain" }, üëà
          ["500 Internal Server Error\n"]]

        def initialize(app, exceptions_app)
          @app = app
          @exceptions_app = exceptions_app
        end

        def call(env)
          request = ActionDispatch::Request.new env
          @app.call(env)
        rescue Exception => exception
          if request.show_exceptions?
            render_exception(request, exception)
          else
            raise exception
          end
        end
      end

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware üëà
      use ActionDispatch::DebugExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware üëà ‚ÅâÔ∏è
      use ActionDispatch::DebugExceptions
      # ...

section.center
  pre.fragment(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def render_exception_with_web_console(request, exception)
          render_exception_without_web_console(request, exception).tap do
            backtrace_cleaner = request.get_header("action_dispatch.backtrace_cleaner")
            error = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).exception

            # Get the original exception if ExceptionWrapper decides to follow it.
            Thread.current[:__web_console_exception] = error

            # ActionView::Template::Error bypass ExceptionWrapper original
            # exception following. The backtrace in the view is generated from
            # reaching out to cause in the view.
            if error.is_a?(ActionView::Template::Error)
              Thread.current[:__web_console_exception] = error.cause
            end
          end
        end

        alias_method :render_exception_without_web_console, :render_exception
        alias_method :render_exception, :render_exception_with_web_console
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def render_exception_with_web_console(request, exception)
          render_exception_without_web_console(request, exception).tap do
            backtrace_cleaner = request.get_header("action_dispatch.backtrace_cleaner")
            error = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).exception

            # Get the original exception if ExceptionWrapper decides to follow it.
            Thread.current[:__web_console_exception] = error

            # ActionView::Template::Error bypass ExceptionWrapper original
            # exception following. The backtrace in the view is generated from
            # reaching out to cause in the view.
            if error.is_a?(ActionView::Template::Error)
              Thread.current[:__web_console_exception] = error.cause
            end
          end
        end

        alias_method :render_exception_without_web_console, :render_exception üëà
        alias_method :render_exception, :render_exception_with_web_console
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def render_exception_with_web_console(request, exception)
          render_exception_without_web_console(request, exception).tap do
            backtrace_cleaner = request.get_header("action_dispatch.backtrace_cleaner")
            error = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).exception üëà

            # Get the original exception if ExceptionWrapper decides to follow it.
            Thread.current[:__web_console_exception] = error

            # ActionView::Template::Error bypass ExceptionWrapper original
            # exception following. The backtrace in the view is generated from
            # reaching out to cause in the view.
            if error.is_a?(ActionView::Template::Error)
              Thread.current[:__web_console_exception] = error.cause
            end
          end
        end

        alias_method :render_exception_without_web_console, :render_exception
        alias_method :render_exception, :render_exception_with_web_console
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def render_exception_with_web_console(request, exception)
          render_exception_without_web_console(request, exception).tap do
            backtrace_cleaner = request.get_header("action_dispatch.backtrace_cleaner")
            error = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).exception

            # Get the original exception if ExceptionWrapper decides to follow it.
            Thread.current[:__web_console_exception] = error üëà

            # ActionView::Template::Error bypass ExceptionWrapper original
            # exception following. The backtrace in the view is generated from
            # reaching out to cause in the view.
            if error.is_a?(ActionView::Template::Error)
              Thread.current[:__web_console_exception] = error.cause
            end
          end
        end

        alias_method :render_exception_without_web_console, :render_exception
        alias_method :render_exception, :render_exception_with_web_console
      end


section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def render_exception_with_web_console(request, exception)
          render_exception_without_web_console(request, exception).tap do
            backtrace_cleaner = request.get_header("action_dispatch.backtrace_cleaner")
            error = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).exception

            # Get the original exception if ExceptionWrapper decides to follow it.
            Thread.current[:__web_console_exception] = error

            # ActionView::Template::Error bypass ExceptionWrapper original
            # exception following. The backtrace in the view is generated from
            # reaching out to cause in the view.
            if error.is_a?(ActionView::Template::Error) üëà
              Thread.current[:__web_console_exception] = error.cause
            end
          end
        end

        alias_method :render_exception_without_web_console, :render_exception
        alias_method :render_exception, :render_exception_with_web_console
      end

section.center data-background="#F00"
  h2.white üôà üôâ üôä

section.center data-background="#F00"
  h2.white Rails 6

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Railtie < ::Rails::Railtie
        initializer 'web_console.initialize' do
          ActionDispatch::DebugExceptions
            .register_interceptor(WebConsole::Interceptor.new)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Interceptor
        def call(request, exception)
          backtrace_cleaner = request.get_header('action_dispatch.backtrace_cleaner')
          error = ExceptionWrapper.new(backtrace_cleaner, exception).exception

          # Get the original exception if ExceptionWrapper decides to follow it.
          Thread.current[:__web_console_exception] = error

          # ActionView::Template::Error bypass ExceptionWrapper original
          # exception following. The backtrace in the view is generated from
          # reaching out to original_exception in the view.
          if error.is_a?(ActionView::Template::Error)
            Thread.current[:__web_console_exception] = error.cause
          end
        end
      end

section.center data-background="#F00"
  p.white The Interceptor API

section.center data-background="#F00"
  h2.white üôÖ‚Äç‚ôÄÔ∏èüêí 

section.center data-background="#000"
  h2.white Application vs Framework Bindings

section.center data-background-iframe="/error"
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::ExceptionMapper
        def initialize(exception)
          @backtrace = exception.backtrace
          @bindings = exception.bindings
        end

        def first
          guess_the_first_application_binding || @bindings.first
        end

        def [](index)
          guess_binding_for_index(index) || @bindings[index]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::ExceptionMapper
        def initialize(exception)
          @backtrace = exception.backtrace üëà
          @bindings = exception.bindings
        end

        def first
          guess_the_first_application_binding || @bindings.first
        end

        def [](index)
          guess_binding_for_index(index) || @bindings[index]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::ExceptionMapper
        def initialize(exception)
          @backtrace = exception.backtrace
          @bindings = exception.bindings üëà
        end

        def first
          guess_the_first_application_binding || @bindings.first
        end

        def [](index)
          guess_binding_for_index(index) || @bindings[index]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::ExceptionMapper
        def first
          guess_the_first_application_binding || @bindings.first
        end

        private

          def guess_the_first_application_binding
            @bindings.find do |binding|
              binding.eval("__FILE__").to_s.start_with?(Rails.root.to_s)
            end
          end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::ExceptionMapper
        def first
       üëâ guess_the_first_application_binding || @bindings.first
        end

        private

          def guess_the_first_application_binding
            @bindings.find do |binding|
              binding.eval("__FILE__").to_s.start_with?(Rails.root.to_s)
            end
          end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::ExceptionMapper
        def first
          guess_the_first_application_binding || @bindings.first üëà
        end

        private

          def guess_the_first_application_binding
            @bindings.find do |binding|
              binding.eval("__FILE__").to_s.start_with?(Rails.root.to_s)
            end
          end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::ExceptionMapper
        def [](index)
          guess_binding_for_index(index) || @bindings[index]
        end

        private

          def guess_binding_for_index(index)
            file, line = @backtrace[index].to_s.split(":")
            line = line.to_i

            @bindings.find do |binding|
              binding.eval("__FILE__") == file && binding.eval("__LINE__") == line
            end
          end
      end

section.center data-background="#000"
  = copyright "roh design", "http://rohdesign.com/weblog/2011/5/16/pipeline-railsconf-illustration.html"
section data-background=image_path("future.png")
  h2.white.fragment Future
  = copyright "roh design", "http://rohdesign.com/weblog/2011/5/16/pipeline-railsconf-illustration.html"

section.center
  h2 Binding#console

section.center
  h2 Actionable Errors

section.center
  h2 Nicer UX

section.center
  h2 Browser Extensions

section.center
  h2 Always On‚Ñ¢Ô∏è 

section.center
  h2 üëå

section.center
  h2 Binding Reaping

section.center
  h2 Production Mode<span class="red">?</span>
section.center data-background="#000"
  h2.white Production Mode<span class="red">?</span>
section.center data-background="#000"
  h2.white üò±

section.center
  h2 Optional Bindex

section.center
  h2 <strike>Optional Bindex</strike>

section.center
  h2 Optional Skiptrace <span class="fragment">üòÖ</span>

section.center
  h2 Rack Application for Authentication

section.center data-background="#000"
  h2 üí•

section.center data-background="#000"
  h1.white.fragment üôè

section.center data-background="#000"
  h1.white.fragment Thanks<span class="red">!</span>
