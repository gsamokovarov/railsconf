section.center
  h2 👋

section.center
  img.inline src=image_path("me.png")
  h2 Genadi Samokovarov

section.center
  a(href="https://twitter.com/gsamokovarov") twitter.com/gsamokovarov

section.center
  a(href="https://github.com/gsamokovarov") github.com/gsamokovarov

section.center
  a href="https://receipt-bank.com"
    img.inline src="https://www.receipt-bank.com/us/wp-content/themes/receipt-bank/dist/images/rb-logo.svg"

section.center data-background-iframe="https://www.receipt-bank.com/us/"
  a(href="#" class="navigate-next") &gt;

section.center data-background="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Flag_of_Bulgaria.svg/2000px-Flag_of_Bulgaria.svg.png"
  h2.white.shadow Bulgaria
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Bulgaria"

section.center data-background="https://www.mapsland.com/maps/europe/bulgaria/large-location-map-of-bulgaria.jpg"
  h2.shadow Bulgaria
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Bulgaria"

section.center data-background="https://upload.wikimedia.org/wikipedia/commons/3/3c/Aleko_konstantinov.jpg"
  h2.white.shadow Aleko Konstantinov
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Aleko_Konstantinov"

section.center
  img.inline src="http://www.bgbestseller.com/25-thickbox_default/-.jpg"
  p To Chicago and Back
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/To_Chicago_and_Back"

section.center data-background="http://www.norblomplumbing.com/img/Minneapolis.jpg"
  h2.white.shadow Minneapolis
  = copyright "Wikipedia", "https://en.wikipedia.org/wiki/Minneapolis"

section.center data-background=asset_path("take_that_aleko.png")
  = copyright "Google Maps", "https://maps.google.com"

section.center
  img.inline src=asset_path("to_minneapolis_and_back.png")
  p To Minneapolis and Back

section data-background="https://cdn2.wanderlust.co.uk/media/2637/articles-public-mineral-baths-sofia-bulgaria-dreamstime.jpg"
  h2.white.shadow Sofia
  = copyright "Wanderlust", "https://www.wanderlust.co.uk/content/short-break-guide-to-sofia-bulgaria/"

section data-background="https://cdn2.wanderlust.co.uk/media/2632/magazine-1335.jpg"
  h2.white.shadow Sofia
  = copyright "Wanderlust", "https://www.wanderlust.co.uk/content/short-break-guide-to-sofia-bulgaria/"

section data-background="https://cdn2.wanderlust.co.uk/media/2633/magazine-2328.jpg"
  h2.white.shadow Sofia
  = copyright "Wanderlust", "https://www.wanderlust.co.uk/content/short-break-guide-to-sofia-bulgaria/"

section data-background="https://processflows.co.uk/wp-content/blogs.dir/1/files/2015/01/bpoFotolia_29276575_M-1.jpg"
  h2.white.shadow Sofia
  = copyright "ProcessFlows", "https://processflows.co.uk"

section.center data-background="#FCD846"
  a href="https://balkanruby.com"
    img.inline src=image_path("balkan.svg")
  p 17–18 May in Sofia, Bulgaria

section.center data-background="#000"
  h1.white.fragment Resolve Errors Straight from the Error Pages!

section.center
  h2 Rails 5.2

section data-background-iframe="https://weblog.rubyonrails.org/2017/11/27/Rails-5-2-Active-Storage-Redis-Cache-Store-HTTP2-Early-Hints-Credentials/"
  a(href="#" class="navigate-next") &gt;

section data-background-iframe="https://edgeguides.rubyonrails.org/active_storage_overview.html"
  a(href="#" class="navigate-next") &gt;

section.center
  h2 Rails 6.0

section data-background-iframe="https://weblog.rubyonrails.org/2019/1/18/Rails-6-0-Action-Mailbox-Action-Text-Multiple-DBs-Parallel-Testing/"
  a(href="#" class="navigate-next") &gt;

section data-background-iframe="https://edgeguides.rubyonrails.org/action_mailbox_basics.html"
  a(href="#" class="navigate-next") &gt;

section data-background-iframe="https://edgeguides.rubyonrails.org/action_text_overview.html"
  a(href="#" class="navigate-next") &gt;

section.center
  = copyright "Demo", "http://localhost:3000"

section.center data-background="http://i.imgur.com/FoSU23L.gif"
  = copyright "Demo", "http://localhost:3000"

section.center data-background="#F00"
  h2.white.fragment Actionable Errors

section.center
  p Actionable errors let's you dispatch actions from Rails' error pages.

section.center
  h3 Credits
  ul
    li <a href="https://github.com/vipulnsward">Vipul A M</a> in <a href="https://github.com/rails/rails/pull/26542">rails/rails#26542</a>
    li <a href="https://github.com/causztic">Yao Jie</a> in <a href="https://summerofcode.withgoogle.com/archive/2018/projects/6742288784949248/">GSoC 2018</a>
    li <a href="https://github.com/gsamokovarov">Genadi Samokovarov</a> in <a href="https://github.com/rails/rails/pull/34788">rails/rails#34788</a>

section.center
  pre(contenteditable=true): code.ruby
    '
      class PendingMigrationError < MigrationError
        include ActiveSupport::ActionableError

        action "Run pending migrations" do
          ActiveRecord::Tasks::DatabaseTasks.migrate
        end
      end

section.center data-background-iframe="/action"
  a(href="#" class="navigate-next") &gt;

section.center data-background="#000"
  p.white.fragment We're in the Unpacking Rails track 🤔

section.center data-background="https://thumbs.gfycat.com/SlowInfantileCusimanse-size_restricted.gif"

section.center data-background="https://thumbs.gfycat.com/SlowInfantileCusimanse-size_restricted.gif"
  h2.white.shadow Error Handling in Rails

section.center data-background="https://thumbs.gfycat.com/SlowInfantileCusimanse-size_restricted.gif"
  h2.white Rack

section.center
  p Rack is a protocol between Ruby web servers and frameworks.

section.center data-background="#000"
  h2.white Rack Application

section.center
  pre(contenteditable=true): code.ruby
    '
      require 'rack'

      app = proc do |env|
        ['200', {'Content-Type' => 'text/html'}, ['A barebones rack app.']]
      end

      Rack::Handler::WEBrick.run app

section.center
  pre(contenteditable=true): code.ruby
    '
      require 'rack'

      app = proc do |env| 👈
        ['200', {'Content-Type' => 'text/html'}, ['A barebones rack app.']]
      end

      Rack::Handler::WEBrick.run app

section.center
  pre(contenteditable=true): code.ruby
    '
      require 'rack'

      app = proc do |env|
        ['200', {'Content-Type' => 'text/html'}, ['A barebones rack app.']] 👈
      end

      Rack::Handler::WEBrick.run app

section.center data-background="#000"
  p.white The foundation of HTTP middlewares in the Ruby 🌍

  = copyright "Rack Specification", "http://www.rubydoc.info/github/rack/rack/master/file/SPEC"

section.center data-background="#000"
  h2.white Rack Middleware

section.center
  pre: code.ruby contenteditable=true
    '
      class Middleware
        def initialize(app)
          @app = app
        end

        def call(env)
          # Pass control to the next request handler.
          @app.call(env)
        end
      end

section.center
  pre: code.ruby contenteditable=true
    '
      class Middleware
        def initialize(app)
          @app = app 👈
        end

        def call(env)
          # Pass control to the next request handler.
          @app.call(env)
        end
      end

section.center
  pre: code.ruby contenteditable=true
    '
      class Middleware
        def initialize(app)
          @app = app
        end

        def call(env)
          # Pass control to the next request handler.
          @app.call(env) 👈
        end
      end

section.center
  pre: code.ruby contenteditable=true
    '
      class Middleware
        def initialize(app)
          @app = app
        end

        def call(env)
          # Or stop the request here and return.
          ['200', {'Content-Type' => 'text/html'}, ['A barebones rack app.']] 👈
        end
      end

section.center data-background="#000"
  h2.white Rails Middleware Stack

section.center
  img.inline src=image_path("browser_to_rails.svg")

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      use ActionDispatch::HostAuthorization
      use Rack::Sendfile
      use ActionDispatch::Static
      use ActionDispatch::Executor
      use ActiveSupport::Cache::Strategy::LocalCache::Middleware
      use Rack::Runtime
      use Rack::MethodOverride
      use ActionDispatch::RequestId
      use ActionDispatch::RemoteIp
      use Sprockets::Rails::QuietAssets
      use Rails::Rack::Logger
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      use ActionDispatch::Reloader
      use ActionDispatch::Callbacks
      use ActiveRecord::Migration::CheckPending
      use ActionDispatch::Cookies
      use ActionDispatch::Session::CookieStore
      use ActionDispatch::Flash
      use ActionDispatch::ContentSecurityPolicy::Middleware
      use Rack::Head
      use Rack::ConditionalGet
      use Rack::ETag
      use Rack::TempfileReaper
      run Banitsa::Application.routes


section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions 👈
      use ActionDispatch::ActionableExceptions
      # ...

section.center data-background="#F00"
  h2.white ActionDispatch::DebugExceptions

section.center data-background-iframe="/error"
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env) 👈

          response
        rescue Exception => exception
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception 👈
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception)
        end
      end

section.center
  img.inline src=image_path("browser_to_rails.svg")

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception 👈
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions? 👈
          render_exception(request, exception)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception) 👈
        end
      end

section.center data-background-iframe="/error"
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions 👈
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      # ...

section.center data-background="#F00"
  h2.white ActionDispatch::ShowExceptions

section.center data-background-iframe="/500"
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ShowExceptions
        FAILSAFE_RESPONSE = [500, { "Content-Type" => "text/plain" },
          ["500 Internal Server Error\n"]]

        def initialize(app, exceptions_app)
          @app = app
          @exceptions_app = exceptions_app
        end

        def call(env)
          request = ActionDispatch::Request.new env
          @app.call(env)
        rescue Exception => exception
          if request.show_exceptions?
            render_exception(request, exception)
          else
            raise exception
          end
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ShowExceptions
        FAILSAFE_RESPONSE = [500, { "Content-Type" => "text/plain" },
          ["500 Internal Server Error\n"]]

        def initialize(app, exceptions_app)
          @app = app
          @exceptions_app = exceptions_app 👈
        end

        def call(env)
          request = ActionDispatch::Request.new env
          @app.call(env)
        rescue Exception => exception
          if request.show_exceptions?
            render_exception(request, exception)
          else
            raise exception
          end
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::PublicExceptions
        attr_accessor :public_path

        def call(env)
          request      = ActionDispatch::Request.new(env)
          status       = request.path_info[1..-1].to_i
          content_type = ...

          render status, content_type,
            status: status,
            error: Rack::Utils::HTTP_STATUS_CODES.fetch(status, Rack::Utils::HTTP_STATUS_CODES[500])
        end

        private
          def render(status, content_type, body)
            path = "\#{public_path}/\#{status}.html"

            render_format(status, "text/html", File.read(path))
          end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ShowExceptions
        FAILSAFE_RESPONSE = [500, { "Content-Type" => "text/plain" },
          ["500 Internal Server Error\n"]]

        def initialize(app, exceptions_app)
          @app = app
          @exceptions_app = exceptions_app
        end

        def call(env)
          request = ActionDispatch::Request.new env
          @app.call(env) 👈
        rescue Exception => exception
          if request.show_exceptions?
            render_exception(request, exception)
          else
            raise exception
          end
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ShowExceptions
        FAILSAFE_RESPONSE = [500, { "Content-Type" => "text/plain" },
          ["500 Internal Server Error\n"]]

        def initialize(app, exceptions_app)
          @app = app
          @exceptions_app = exceptions_app
        end

        def call(env)
          request = ActionDispatch::Request.new env
          @app.call(env)
        rescue Exception => exception 👈
          if request.show_exceptions?
            render_exception(request, exception)
          else
            raise exception
          end
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ShowExceptions
        FAILSAFE_RESPONSE = [500, { "Content-Type" => "text/plain" },
          ["500 Internal Server Error\n"]]

        def initialize(app, exceptions_app)
          @app = app
          @exceptions_app = exceptions_app
        end

        def call(env)
          request = ActionDispatch::Request.new env
          @app.call(env)
        rescue Exception => exception
          if request.show_exceptions?
            render_exception(request, exception) 👈
          else
            raise exception
          end
        end
      end

section.center data-background-iframe="/500"
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.html
    '
      # public/500.html
      <title>We're sorry, but something went wrong (500)</title>

      <div class="dialog">
        <div>
          <h1>We're sorry, but something went wrong.</h1>
        </div>
        <p>If you are the application owner check the logs for more information.</p>
      </div>

section.center
  img.inline src="https://i0.kym-cdn.com/photos/images/facebook/001/082/352/5ba.png"

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ShowExceptions
        FAILSAFE_RESPONSE = [500, { "Content-Type" => "text/plain" }, 👈
          ["500 Internal Server Error\n"]]

        def initialize(app, exceptions_app)
          @app = app
          @exceptions_app = exceptions_app
        end

        def call(env)
          request = ActionDispatch::Request.new env
          @app.call(env)
        rescue Exception => exception
          if request.show_exceptions?
            render_exception(request, exception)
          else
            raise exception
          end
        end
      end

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware 👈
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      # ...

section.center data-background="#F00"
  h2.white WebConsole::Middleware

section.center data-background-iframe="/error"
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.permitted?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.permitted? 👈

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.permitted?

          if id = id_for_repl_session_update(request) 👈
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center data-background-iframe="/console"
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.permitted?

          if id = id_for_repl_session_update(request) 👈
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.permitted?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request) 👈
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.permitted?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env) 👈

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  img.inline src=image_path("browser_to_rails_with_web_console.svg")

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.permitted?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env) 👈

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.permitted?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) 👈 && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.permitted?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers) 👈
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Middleware
        def call(env)
          request = create_regular_or_whiny_request(env)
          return @app.call(env) unless request.permitted?

          if id = id_for_repl_session_update(request)
            return update_repl_session(id, request)
          elsif id = id_for_repl_session_stack_frame_change(request)
            return change_stack_trace(id, request)
          end

          status, headers, body = @app.call(env)

          if (session = Session.from(Thread.current)) && acceptable_content_type?(headers)
            template = Template.new(env, session)
            body, headers = Injector.new(body, headers).inject(template.render("index"))
          end

          [ status, headers, body ] 👈
        end
      end

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware 👈
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware 👈 ⁉️
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      # ...

section.center
  h2 Rails 5.2

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def render_exception_with_web_console(request, exception)
          render_exception_without_web_console(request, exception).tap do
            backtrace_cleaner = request.get_header("action_dispatch.backtrace_cleaner")
            error = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).exception

            # Get the original exception if ExceptionWrapper decides to follow it.
            Thread.current[:__web_console_exception] = error

            # ActionView::Template::Error bypass ExceptionWrapper original
            # exception following. The backtrace in the view is generated from
            # reaching out to cause in the view.
            if error.is_a?(ActionView::Template::Error)
              Thread.current[:__web_console_exception] = error.cause
            end
          end
        end

        alias_method :render_exception_without_web_console, :render_exception
        alias_method :render_exception, :render_exception_with_web_console
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def render_exception_with_web_console(request, exception)
          render_exception_without_web_console(request, exception).tap do
            backtrace_cleaner = request.get_header("action_dispatch.backtrace_cleaner")
            error = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).exception

            # Get the original exception if ExceptionWrapper decides to follow it.
            Thread.current[:__web_console_exception] = error

            # ActionView::Template::Error bypass ExceptionWrapper original
            # exception following. The backtrace in the view is generated from
            # reaching out to cause in the view.
            if error.is_a?(ActionView::Template::Error)
              Thread.current[:__web_console_exception] = error.cause
            end
          end
        end

        alias_method :render_exception_without_web_console, :render_exception 👈
        alias_method :render_exception, :render_exception_with_web_console
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def render_exception_with_web_console(request, exception)
          render_exception_without_web_console(request, exception).tap do
            backtrace_cleaner = request.get_header("action_dispatch.backtrace_cleaner")
            error = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).exception 👈

            # Get the original exception if ExceptionWrapper decides to follow it.
            Thread.current[:__web_console_exception] = error

            # ActionView::Template::Error bypass ExceptionWrapper original
            # exception following. The backtrace in the view is generated from
            # reaching out to cause in the view.
            if error.is_a?(ActionView::Template::Error)
              Thread.current[:__web_console_exception] = error.cause
            end
          end
        end

        alias_method :render_exception_without_web_console, :render_exception
        alias_method :render_exception, :render_exception_with_web_console
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def render_exception_with_web_console(request, exception)
          render_exception_without_web_console(request, exception).tap do
            backtrace_cleaner = request.get_header("action_dispatch.backtrace_cleaner")
            error = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).exception

            # Get the original exception if ExceptionWrapper decides to follow it.
            Thread.current[:__web_console_exception] = error 👈

            # ActionView::Template::Error bypass ExceptionWrapper original
            # exception following. The backtrace in the view is generated from
            # reaching out to cause in the view.
            if error.is_a?(ActionView::Template::Error)
              Thread.current[:__web_console_exception] = error.cause
            end
          end
        end

        alias_method :render_exception_without_web_console, :render_exception
        alias_method :render_exception, :render_exception_with_web_console
      end


section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def render_exception_with_web_console(request, exception)
          render_exception_without_web_console(request, exception).tap do
            backtrace_cleaner = request.get_header("action_dispatch.backtrace_cleaner")
            error = ActionDispatch::ExceptionWrapper.new(backtrace_cleaner, exception).exception

            # Get the original exception if ExceptionWrapper decides to follow it.
            Thread.current[:__web_console_exception] = error

            # ActionView::Template::Error bypass ExceptionWrapper original
            # exception following. The backtrace in the view is generated from
            # reaching out to cause in the view.
            if error.is_a?(ActionView::Template::Error) 👈
              Thread.current[:__web_console_exception] = error.cause
            end
          end
        end

        alias_method :render_exception_without_web_console, :render_exception
        alias_method :render_exception, :render_exception_with_web_console
      end

section.center data-background="#F00"
  h2.white 🙈 🙉 🙊

section.center data-background="#F00"
  h2.white Rails 6

section.center data-background="#F00"
  h2.white The Interceptor API

section.center data-background="#F00"
  h2.white 🙅‍♀️🐒 

section.center
  pre(contenteditable=true): code.ruby
    '
      class WebConsole::Railtie < ::Rails::Railtie
        initializer 'web_console.initialize' do
          ActionDispatch::DebugExceptions
            .register_interceptor(WebConsole::Interceptor)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      module WebConsole::Interceptor
        def self.call(request, exception)
          backtrace_cleaner = request.get_header('action_dispatch.backtrace_cleaner')
          error = ExceptionWrapper.new(backtrace_cleaner, exception).exception

          # Get the original exception if ExceptionWrapper decides to follow it.
          Thread.current[:__web_console_exception] = error

          # ActionView::Template::Error bypass ExceptionWrapper original
          # exception following. The backtrace in the view is generated from
          # reaching out to original_exception in the view.
          if error.is_a?(ActionView::Template::Error)
            Thread.current[:__web_console_exception] = error.cause
          end
        end
      end

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions 👈
      use ActionDispatch::ActionableExceptions
      # ...

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception
          invoke_interceptors(request, exception) 👈
          raise exception unless request.show_exceptions?
          render_exception(request, exception)
        end
      end

section.center data-background="#000"
  h2.white Application vs Framework Traces

section.center data-background-iframe="/error"
  a(href="#" class="navigate-next") &gt;

section.center data-background="#F00"
  h2.white Actionable Errors

section.center data-background-iframe="/migration"
  a(href="#" class="navigate-next") &gt;

section.center
  pre(contenteditable=true): code.ruby
    '
      class PendingMigrationError < MigrationError
        include ActiveSupport::ActionableError

        action "Run pending migrations" do
          ActiveRecord::Tasks::DatabaseTasks.migrate
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class PendingMigrationError < MigrationError
        include ActiveSupport::ActionableError 👈

        action "Run pending migrations" do
          ActiveRecord::Tasks::DatabaseTasks.migrate
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class PendingMigrationError < MigrationError
        include ActiveSupport::ActionableError

        action "Run pending migrations" do 👈
          ActiveRecord::Tasks::DatabaseTasks.migrate
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class PendingMigrationError < MigrationError
        include ActiveSupport::ActionableError

        action "Run pending migrations" do
          ActiveRecord::Tasks::DatabaseTasks.migrate 👈
        end
      end

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions
      # ...

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions 👈
      use ActionDispatch::ActionableExceptions
      # ...

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::DebugExceptions
        def call(env)
          request = ActionDispatch::Request.new env
          _, headers, body = response = @app.call(env)

          response
        rescue Exception => exception
          invoke_interceptors(request, exception)
          raise exception unless request.show_exceptions?
          render_exception(request, exception) 👈
        end
      end

section.center
  pre(contenteditable=true): code.html
    '
      # action_dispatch/middleware/templates/rescues/diagnostics.html.erb
      <%= render "rescues/actions", exception: @exception, request: @request %>

section.center
  pre(contenteditable=true): code.html
    '
      # action_dispatch/middleware/templates/rescues/_actions.html.erb
      <% actions = ActiveSupport::ActionableError.actions(exception) %>

      <% if actions.any? %>
        <div class="actions">
          <% actions.each do |action, _| %>
            <%= button_to action, ActionDispatch::ActionableExceptions.endpoint, params: {
              error: exception.class.name,
              action: action,
              location: request.path
            } %>
          <% end %>
        </div>
      <% end %>

section.center
  pre(contenteditable=true): code.shell
    '
      $ rails middleware
      # ...
      use ActionDispatch::ShowExceptions
      use WebConsole::Middleware
      use ActionDispatch::DebugExceptions
      use ActionDispatch::ActionableExceptions 👈
      # ...

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ActionableExceptions
        def call(env)
          request = ActionDispatch::Request.new(env)
          return @app.call(env) unless actionable_request?(request)

          ActiveSupport::ActionableError.dispatch \
            request.params[:error].to_s.safe_constantize,
            request.params[:action]

          redirect_to request.params[:location]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ActionableExceptions
        def call(env)
          request = ActionDispatch::Request.new(env)
          return @app.call(env) unless actionable_request?(request) 👈

          ActiveSupport::ActionableError.dispatch \
            request.params[:error].to_s.safe_constantize,
            request.params[:action]

          redirect_to request.params[:location]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ActionableExceptions
        def call(env)
          request = ActionDispatch::Request.new(env)
          return @app.call(env) unless actionable_request?(request)

          ActiveSupport::ActionableError.dispatch \ 👈
            request.params[:error].to_s.safe_constantize,
            request.params[:action]

          redirect_to request.params[:location]
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionDispatch::ActionableExceptions
        def call(env)
          request = ActionDispatch::Request.new(env)
          return @app.call(env) unless actionable_request?(request)

          ActiveSupport::ActionableError.dispatch \
            request.params[:error].to_s.safe_constantize,
            request.params[:action]

          redirect_to request.params[:location] 👈
        end
      end

section.center
  h2.fragment 😰

section.center
  h2 😴

section.center data-background="https://media1.giphy.com/media/p48F7LHfETH8Y/giphy.gif"
section.center data-background="https://media.giphy.com/media/dEPGknRiEniec/giphy.gif"
section.center data-background="https://media.giphy.com/media/126XZOZ4xUt0NG/giphy.gif"

section.center data-background="#F00"
  h2.white Strategies

section.center data-background="#00F"
  h2.white Middleware Checker

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActiveRecord::Migration::CheckPending
        def initialize(app)
          @app = app
          @last_check = 0
        end

        def call(env)
          mtime = ActiveRecord::Base.connection.migration_context.last_migration.mtime.to_i
          if @last_check < mtime
            ActiveRecord::Migration.check_pending!(ActiveRecord::Base.connection)
            @last_check = mtime
          end
          @app.call(env)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActiveRecord::Migration::CheckPending
        def initialize(app)
          @app = app
          @last_check = 0
        end

        def call(env)
          mtime = ActiveRecord::Base.connection.migration_context.last_migration.mtime.to_i
          if @last_check < mtime
            ActiveRecord::Migration.check_pending!(ActiveRecord::Base.connection) 👈
            @last_check = mtime
          end
          @app.call(env)
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActiveRecord::Railtie < Rails::Railtie
        initializer "active_record.migration_error" do
          if config.active_record.delete(:migration_error) == :page_load
            config.app_middleware.insert_after ::ActionDispatch::Callbacks,
              ActiveRecord::Migration::CheckPending
          end
        end
      end

section.center
  p.fragment Generic approach, but requires too much work... 😕

section.center data-background="#00F"
  h2.white Act on Existing Errors

section.center
  p Work in Progress 🏗

section.center
  a href="https://github.com/rails/rails/pull/36071" rails/rails#36071

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionMailbox::SetupError < ActionMailbox::Error
        include ActiveSupport::ActionableError

        def initialize(message = nil)
          super(message || <<~MESSAGE)
            Action Mailbox does not appear to be installed. Do you want to
            install it now?
          MESSAGE
        end

        action "Install now" do
          Rails::Command.invoke "active_storage:install"
          Rails::Command.invoke "action_mailbox:install"
          Rails::Command.invoke "db:migrate"
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionMailbox::SetupError < ActionMailbox::Error
        include ActiveSupport::ActionableError 👈

        def initialize(message = nil)
          super(message || <<~MESSAGE)
            Action Mailbox does not appear to be installed. Do you want to
            install it now?
          MESSAGE
        end

        action "Install now" do
          Rails::Command.invoke "active_storage:install"
          Rails::Command.invoke "action_mailbox:install"
          Rails::Command.invoke "db:migrate"
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionMailbox::SetupError < ActionMailbox::Error
        include ActiveSupport::ActionableError

        def initialize(message = nil)
          super(message || <<~MESSAGE)
            Action Mailbox does not appear to be installed. Do you want to
            install it now?
          MESSAGE
        end

        action "Install now" do 👈
          Rails::Command.invoke "active_storage:install"
          Rails::Command.invoke "action_mailbox:install"
          Rails::Command.invoke "db:migrate"
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionMailbox::Engine < Rails::Engine
        initializer "action_mailbox.setup" do
          ActionDispatch::ActionableExceptions.on ActiveRecord::StatementInvalid do |err|
            if err.to_s.match?(ActionMailbox::InboundEmail.table_name)
              raise ActionMailbox::SetupError
            end
          end
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionMailbox::Engine < Rails::Engine
        initializer "action_mailbox.setup" do
          ActionDispatch::ActionableExceptions.on ActiveRecord::StatementInvalid do |err| 👈
            if err.to_s.match?(ActionMailbox::InboundEmail.table_name)
              raise ActionMailbox::SetupError
            end
          end
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionMailbox::Engine < Rails::Engine
        initializer "action_mailbox.setup" do
          ActionDispatch::ActionableExceptions.on ActiveRecord::StatementInvalid do |err|
            if err.to_s.match?(ActionMailbox::InboundEmail.table_name) 👈
              raise ActionMailbox::SetupError
            end
          end
        end
      end

section.center
  pre(contenteditable=true): code.ruby
    '
      class ActionMailbox::Engine < Rails::Engine
        initializer "action_mailbox.setup" do
          ActionDispatch::ActionableExceptions.on ActiveRecord::StatementInvalid do |err|
            if err.to_s.match?(ActionMailbox::InboundEmail.table_name)
              raise ActionMailbox::SetupError 👈
            end
          end
        end
      end

section.center
  .fragment
    p Please, give us feedback! 🙏
    a href="https://github.com/rails/rails/pull/36071" rails/rails#36071

section.center data-background="#000"
  h2.white.fragment TL;DR

section.center data-background="#000" data-background-transition="none"
  p.white We can improve the development experience!

section.center data-background="#000" data-background-transition="none"
  p.white Actionable errors are only a single step.

section.center data-background="#000" data-background-transition="none"
  p.white Can be useful for the Rails Conductor.

section.center data-background="https://i.makeagif.com/media/9-17-2015/R3hDjT.gif" 
  p.white.shadow Nobody reads the docs!

section.center
  a href="https://github.com/gsamokovarov/break" gem install break
  = copyright "binding.break", "https://github.com/gsamokovarov/break"

section.center data-background="https://media.giphy.com/media/yoJC2GnSClbPOkV0eA/giphy.gif"
  h1.white.shadow.fragment Thank you!
